name: ğŸš€ Release

permissions:
  contents: write
  actions: write
  attestations: write

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.5.0)'
        required: true
        type: string
      release_type:
        description: 'What to release'
        required: true
        type: choice
        default: 'core+backends'
        options:
          - 'core'
          - 'backends'
          - 'core+backends'
      latest:
        description: 'Mark this release as latest'
        required: false
        type: boolean
        default: false
      create_github_release:
        description: 'Create a GitHub release'
        required: false
        type: boolean
        default: true

jobs:
  validate-inputs:
    name: ğŸ” Validate Inputs
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      release_type: ${{ steps.validate.outputs.release_type }}
      latest: ${{ steps.validate.outputs.latest }}
      create_github_release: ${{ steps.validate.outputs.create_github_release }}
    steps:
      - name: ğŸ” Validate version format
        id: validate
        run: |
          version="${{ github.event.inputs.version }}"
          release_type="${{ github.event.inputs.release_type }}"
          latest="${{ github.event.inputs.latest }}"
          create_github_release="${{ github.event.inputs.create_github_release }}"
          
          # Check if version starts with 'v' and follows semantic versioning
          if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ Error: Version must follow semantic versioning format (e.g., v1.5.0)"
            exit 1
          fi
          
          echo "âœ… Version format is valid: $version"
          echo "ğŸ“¦ Release type: $release_type"
          echo "ğŸ·ï¸ Mark as latest: $latest"
          echo "ğŸ“‹ Create GitHub release: $create_github_release"
          
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "release_type=$release_type" >> $GITHUB_OUTPUT
          echo "latest=$latest" >> $GITHUB_OUTPUT
          echo "create_github_release=$create_github_release" >> $GITHUB_OUTPUT

  discover-backends:
    name: ğŸ” Discover Backends
    runs-on: ubuntu-latest
    needs: validate-inputs
    if: ${{ needs.validate-inputs.outputs.release_type == 'backends' || needs.validate-inputs.outputs.release_type == 'core+backends' }}
    outputs:
      backends: ${{ steps.discover.outputs.backends }}
    steps:
      - name: ğŸ›ï¸ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Discover backends
        id: discover
        run: |
          # Find all backend directories that have go.mod files
          backends=$(find backend -mindepth 1 -maxdepth 1 -type d | sort)
          
          # Filter to only include directories with go.mod files
          backend_list=()
          for backend in $backends; do
            if [[ -f "$backend/go.mod" ]]; then
              backend_name=$(basename "$backend")
              backend_list+=("$backend_name")
              echo "âœ… Found backend: $backend_name"
            fi
          done
          
          # Convert to JSON array
          backends_json=$(printf '%s\n' "${backend_list[@]}" | jq -R . | jq -s . | jq -c .)
          echo "backends=$backends_json" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Discovered backends: $backends_json"

  create-tags:
    name: ğŸ·ï¸ Create and Push Tags
    runs-on: ubuntu-latest
    needs: [validate-inputs, discover-backends]
    if: always() && !cancelled() && !failure()
    steps:
      - name: ğŸ›ï¸ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ·ï¸ Create main project tag
        if: ${{ needs.validate-inputs.outputs.release_type == 'core' || needs.validate-inputs.outputs.release_type == 'core+backends' }}
        run: |
          version="${{ needs.validate-inputs.outputs.version }}"
          
          # Check if tag already exists
          if git tag -l | grep -q "^${version}$"; then
            echo "âš ï¸ Tag $version already exists for main project"
          else
            git tag "$version"
            echo "âœ… Created main project tag: $version"
          fi

      - name: ğŸ·ï¸ Create backend tags
        if: ${{ needs.validate-inputs.outputs.release_type == 'backends' || needs.validate-inputs.outputs.release_type == 'core+backends' }}
        run: |
          version="${{ needs.validate-inputs.outputs.version }}"
          backends='${{ needs.discover-backends.outputs.backends }}'
          
          echo "Creating backend tags for version: $version"
          
          # Parse backends JSON array
          echo "$backends" | jq -r '.[]' | while read -r backend; do
            backend_tag="backend/${backend}/${version}"
            
            # Check if tag already exists
            if git tag -l | grep -q "^${backend_tag}$"; then
              echo "âš ï¸ Tag $backend_tag already exists"
            else
              git tag "$backend_tag"
              echo "âœ… Created backend tag: $backend_tag"
            fi
          done

      - name: ğŸš€ Push main project tag
        if: ${{ needs.validate-inputs.outputs.release_type == 'core' || needs.validate-inputs.outputs.release_type == 'core+backends' }}
        run: |
          version="${{ needs.validate-inputs.outputs.version }}"
          
          echo "Pushing main project tag..."
          git push origin "$version" || echo "âš ï¸ Main project tag $version may already exist remotely"
          echo "ğŸ“¤ Pushed main project tag: $version"

      - name: ğŸš€ Push backend tags
        if: ${{ needs.validate-inputs.outputs.release_type == 'backends' || needs.validate-inputs.outputs.release_type == 'core+backends' }}
        run: |
          version="${{ needs.validate-inputs.outputs.version }}"
          
          echo "Pushing backend tags..."
          backends='${{ needs.discover-backends.outputs.backends }}'
          echo "$backends" | jq -r '.[]' | while read -r backend; do
            backend_tag="backend/${backend}/${version}"
            git push origin "$backend_tag" || echo "âš ï¸ Backend tag $backend_tag may already exist remotely"
            echo "ğŸ“¤ Pushed: $backend_tag"
          done
          
          echo "ğŸ‰ All backend tags pushed successfully!"

  create-github-release:
    name: ğŸ“‹ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-tags]
    if: ${{ needs.validate-inputs.outputs.create_github_release == 'true' && (needs.validate-inputs.outputs.release_type == 'core' || needs.validate-inputs.outputs.release_type == 'core+backends') }}
    steps:
      - name: ğŸ›ï¸ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“‹ Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.validate-inputs.outputs.version }}
          name: Release ${{ needs.validate-inputs.outputs.version }}
          make_latest: ${{ needs.validate-inputs.outputs.latest }}
          generate_release_notes: true
          body: |
            ## KiviGo ${{ needs.validate-inputs.outputs.version }}
            
            ### Installation
            
            ```bash
            go get github.com/azrod/kivigo@${{ needs.validate-inputs.outputs.version }}
            ```
            
            ### Backend Modules
            
            For backend-specific modules, use:
            
            ```bash
            # Redis backend
            go get github.com/azrod/kivigo/backend/redis@backend/redis/${{ needs.validate-inputs.outputs.version }}
            
            # Consul backend  
            go get github.com/azrod/kivigo/backend/consul@backend/consul/${{ needs.validate-inputs.outputs.version }}
            
            # etcd backend
            go get github.com/azrod/kivigo/backend/etcd@backend/etcd/${{ needs.validate-inputs.outputs.version }}
            
            # Badger backend
            go get github.com/azrod/kivigo/backend/badger@backend/badger/${{ needs.validate-inputs.outputs.version }}
            
            # Local (BoltDB) backend
            go get github.com/azrod/kivigo/backend/local@backend/local/${{ needs.validate-inputs.outputs.version }}
            ```
            
            ### Documentation
            
            - ğŸ“š [Documentation](https://azrod.github.io/kivigo/)
            - ğŸ“– [API Reference](https://pkg.go.dev/github.com/azrod/kivigo@${{ needs.validate-inputs.outputs.version }})
            
            ### Release Type
            
            This release includes: **${{ needs.validate-inputs.outputs.release_type }}**

  deploy-docs:
    name: ğŸ“šğŸš€ Deploy Documentation to GitHub Pages
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-tags]
    if: ${{ needs.validate-inputs.outputs.release_type == 'core' || needs.validate-inputs.outputs.release_type == 'core+backends' }}
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    permissions:
      contents: read
      pages: write
      id-token: write
    
    steps:
      - name: ğŸ›ï¸ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CI_PAT }}

      - name: ğŸ“‹ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: website/package-lock.json

      - name: ğŸ“¦ Install dependencies
        run: |
          cd website
          npm ci

      - name: ğŸ“š Create versioned documentation
        run: |
          cd website
          version="${{ needs.validate-inputs.outputs.version }}"
          # Remove 'v' prefix for Docusaurus version
          doc_version=${version#v}
          
          echo "Creating versioned documentation for version: $doc_version"
          
          # Check if this version already exists
          if [[ -f versions.json ]] && jq -e ". | index(\"$doc_version\")" versions.json > /dev/null; then
            echo "â„¹ï¸ Version $doc_version already exists, skipping versioning"
          else
            # Use Docusaurus versioning command to create the version
            npm run version "$doc_version"
            echo "âœ… Created version $doc_version using Docusaurus versioning"
          fi
          
          # Show current versions
          if [[ -f versions.json ]]; then
            echo "ğŸ“‹ Current versions:"
            cat versions.json
          fi

      - name: ğŸ“ Update Docusaurus current version label
        run: |
          cd website
          version="${{ needs.validate-inputs.outputs.version }}"
          doc_version=${version#v}
          # Remplace la valeur de lastVersion dans docusaurus.config.ts
          sed -i.bak -E "s/(lastVersion:\s*')[^']+(',)/\1${doc_version}\2/" docusaurus.config.ts
          rm docusaurus.config.ts.bak

      - name: ğŸ—ï¸ Build website
        run: |
          cd website
          npm run build

      - name: ğŸ—‚ï¸ Setup Pages
        uses: actions/configure-pages@v4

      - name: ğŸ“¤ Upload to GitHub Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: website/build

      - name: ğŸš€ Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: ğŸ“šCommit and push changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: add documentation for version"
          commit_user_name: github-actions[bot]
          commit_user_email: github-actions[bot]@users.noreply.github.com
          commit_author: github-actions[bot] <github-actions[bot]@users.noreply.github.com>